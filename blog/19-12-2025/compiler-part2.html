<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Compiler - Part 2</title>
	<link rel="stylesheet" href="../../static/index.css" />
</head>
<body>
	<header>
		<nav>
    		<a href="/">home</a>
    		<a href="/blog">blog</a>
    		<a href="https://github.com/ayushkumar121">github</a>
    		<a href="https://www.linkedin.com/in/ayush-kumar-b244b8131/">linkedin</a>
		</nav>
	</header>
	<main>
		<article>
		  <h1>Compiler – Part 2</h1>

		  <p>
		    Over the past few weeks, I’ve been working aggressively on my compiler,
		    rewriting large parts of the compilation pipeline and rethinking several
		    design decisions.
		  </p>

		  <h2>Correctness</h2>
		  <p>
		    One of the biggest challenges I faced was identifying <em>where</em> things
		    were going wrong. Was the issue in my intermediate representation, or was it
		    in the assembly generation stage?
		  </p>

		  <p>
		    When you’re building a compiler, this distinction isn’t always obvious.
		    Bugs can surface far downstream from where they were introduced, which
		    makes debugging especially confusing.
		  </p>

		  <h3>Why do we need an intermediate representation?</h3>
		  <p>
		    This is a very reasonable question. Why convert a language into a third
		    format before translating it into real machine code?
		  </p>

		  <p>
		    The short answer is: you don’t have to. It’s perfectly valid to build a
		    compiler without any intermediate representation at all. Many early
		    compilers worked this way, and even today some simple languages are
		    compiled directly to assembly.
		  </p>

		  <p>
		    However, the real benefit of an intermediate representation becomes clear
		    when targeting multiple architectures. Since my goal is to support more
		    than one platform, an IR lets me share the majority of the compilation
		    logic and defer only the platform-specific work to the final stage.
		  </p>

		  <h2>Interpreter Mode</h2>
		  <p>
		    While debugging my compiler, I often ran into situations where multiple
		    fixes seemed possible. Should I change how the IR behaves, or should I fix
		    the code generator?
		  </p>

		  <p>
		    To break this dilemma, I decided to write an interpreter for my
		    intermediate language. This allowed me to validate the compiler logic
		    <em>before</em> generating any assembly code.
		  </p>

		  <p>
		    Working on the interpreter also helped me better understand the level of
		    abstraction my IR should operate at.
		  </p>

		  <p>
		    I loosely modeled the interpreter after the ARM64 architecture, taking
		    shortcuts where appropriate. This helped validate many of the assumptions
		    I was making about the code my compiler emits.
		  </p>

		  <h2>Code Generation</h2>
		  <p>
		    Code generation is often the hardest part of a compiler. It involves
		    translating high-level concepts into very low-level operations.
		  </p>

		  <pre>
		// C
		x = 4;

		// ARM64 assembly
		str #4, [x29, #-16]
		  </pre>

		  <p>
		    At the hardware level, there are no variables—only memory. It’s the
		    compiler’s responsibility to divide that memory into variables and give
		    them meaning through types and conventions.
		  </p>

		  <p>
		    I’m far from an assembly expert. In fact, I had no prior experience with
		    ARM64 before starting this project. While online documentation is helpful,
		    it can also be overwhelming.
		  </p>

		  <p>
		    One tool that helped me immensely was
		    <a href="https://godbolt.org/">Compiler Explorer (Godbolt)</a>, which made it
		    much easier to understand how high-level code maps to assembly.
		  </p>
		</article>
		<footer>
			reach out to me <a href="mailto:ayushkumar121@outlook.com">ayushkumar121@outlook.com</a>
		</footer>
	</main>
</body>
</html>